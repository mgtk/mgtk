<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook V3.1//EN">
<article>
<artheader>
  <title>mGtk -- an SML binding for Gtk</title>
  <subtitle>Generator Documentation</subtitle>
  <pubdate>March 2000</pubdate>
  <author>
    <firstname>Henning</firstname>
    <surname>Niss</surname>
  </author>
  <copyright>
     <year>1999</year>
     <year>2000</year>
     <holder>Ken Friis Larsen</holder>
     <holder>Henning Niss</holder>
  </copyright>
</artheader>

<para>
This document contains some brief comments about the workings of the
program that generates the mGtk binding files
(<filename>Gtk.sig</filename>, <filename>Gtk.sml</filename>, and
<filename>mgtk.c</filename>). We shall refer to the program as ``the
generator'' for lack of a better name.
</para>

<sect1><title>Invocation</title>

<para>
The generator can be invoked with the following command-line options:

  <cmdsynopsis>
    <command>generator</command>
    <arg>-c</arg>
    <arg>-sig</arg>
    <arg>-sml</arg>
    <arg>-o <replaceable>file</replaceable></arg>

    <arg>-h <replaceable>file</replaceable></arg>
    <arg>--header <replaceable>file</replaceable></arg>
    <arg>--no-header</arg>

    <arg>-f <replaceable>file</replaceable></arg>
    <arg>--footer <replaceable>file</replaceable></arg>
    <arg>-end</arg>
    <arg>--end-footer</arg>
    <arg>--no-footer</arg>

    <arg>-V</arg>
    <arg>--version</arg>

    <arg>-v</arg>
    <arg>--verbose</arg>
  
    <arg choice=req><replaceable>file</replaceable></arg>
  </cmdsynopsis>
</para>

<para>
The options have the following meanings:

  <variablelist>

  <varlistentry><term><option>-c</option></term>
    <listitem><para>
       Generate C code. Will set header to
       <filename>header.c</filename> (see <option>--no-header</option>
       below). This is the default target language.
    </para></listitem>
  </varlistentry>

  <varlistentry><term><option>-sig</option></term>
    <listitem><para>
       Generate an SML signature. Will set header to
       <filename>header.sig</filename> and implies
       <option>--end-footer</option> (see <option>--no-header</option>
       below).
    </para></listitem>
  </varlistentry>

  <varlistentry><term><option>-sml</option></term>
    <listitem><para>
       Generate an SML structure. Will set header to
       <filename>header.sml</filename> and implies
       <option>--end-footer</option> (see <option>--no-header</option>
       below).
    </para></listitem>
  </varlistentry>
				   
  <varlistentry><term><option>-o <replaceable>file</replaceable></option></term>
    <listitem><para>
         Sets the output file to <replaceable>file</replaceable>. All output
         goes to <replaceable>file</replaceable>.  The default is to output
         on <filename>stdout</filename>.
    </para></listitem>
  </varlistentry>

  <varlistentry><term><option>-h <replaceable>file</replaceable></option></term>
    <listitem><para>
         Sets the header file to <replaceable>file</replaceable>. The header
         file is included after the copyright message, but before the
         generated code. This is implied by <option>-c</option>,
         <option>-sig</option>, and <option>-sml</option> above.
    </para></listitem>
  </varlistentry>

  <varlistentry><term><option>--header <replaceable>file</replaceable></option></term>
    <listitem><para>Same as <option>-h <replaceable>file</replaceable></option></para></listitem>
  </varlistentry>

  <varlistentry><term><option>--no-header</option></term>
    <listitem><para>
         Don't insert a header. Since <option>-c</option>,
         <option>-sig</option>, and <option>-sml</option>
         automatically sets the header, in order to avoid headers with
         these options, <option>--no-header</option> must appear
         <emphasis>after</emphasis> the target option.
    </para></listitem>
  </varlistentry>

  <varlistentry><term><option>-f <replaceable>file</replaceable></option></term>
    <listitem><para>
         Sets the footer file to <replaceable>file</replaceable>. The footer
         file is included after the generated code.
    </para></listitem>
  </varlistentry>

  <varlistentry><term><option>--footer <replaceable>file</replaceable></option></term>
    <listitem><para>Same as <option>-f <replaceable>file</replaceable></option></para></listitem>
  </varlistentry>

  <varlistentry><term><option>-end</option></term>
    <listitem><para>
        Inserts <syntax>end</syntax> as the footer. This is implied by
        <option>-sig</option> and <option>-sml</option> above to end
        the signature/structure declaration.
    </para></listitem>
  </varlistentry>

  <varlistentry><term><option>--end-footer</option></term>
    <listitem><para>Same as <option>-end</option></para></listitem>
  </varlistentry>

  <varlistentry><term><option>--no-footer</option></term>
    <listitem><para>
         Don't insert a footer. Since <option>-sig</option> and
         <option>-sml</option> automatically sets the footer to
         <option>-end</option>, this option must appear after the
         target option.
    </para></listitem>
  </varlistentry>

  <varlistentry><term><option>-V</option></term>
    <listitem><para>Show version information</para></listitem>
  </varlistentry>

  <varlistentry><term><option>--version</option></term>
    <listitem><para>Same as <option>-V</option></para></listitem>
  </varlistentry>

  <varlistentry><term><option>-v</option></term>
    <listitem><para>
         Display extra (debug) messages. This is not very usefull
         currently since it only tells you which options have been
         seen.
    </para></listitem>
  </varlistentry>

  <varlistentry><term><option>--verbose</option></term>
    <listitem><para>Same as <option>-v</option></para></listitem>
  </varlistentry>

  <varlistentry><term><replaceable>file</replaceable></term>
    <listitem><para>
        The <filename>.defs</filename> file to be processed.
    </para></listitem>
  </varlistentry>

  </variablelist>
</para>

</sect1>


<sect1><title>Accepted Syntax</title>

<para>
The generator accepts <filename>.defs</filename> files complying with
the following grammar.
</para>

<para>
<programlisting>
<![CDATA[
  <decls> ::=  <decl>+

  <decl> ::=  <obj-decl>   |  <func-decl>  
          |   <enum-decl>  |  <boxed-decl>  |  <signal-decl>

  <obj-decl> ::=  "(" "define-object" <name> <inherits> [<fields>] ")"
  <inherits> ::=  "(" <name> ")"
  <fields>   ::=  "(" "fields" <pars> ")"

  <func-decl> ::=  "(" "define-func" <name> <type> <pardefaults> ")"

  <enum-decl> ::=  "(" "define-enum" <name> <constructors> ")"
               |   "(" "define-flag" <name> <constructors> ")"
  <constructors> ::=  <constructor>+
  <constructor>  ::=  "(" <name> <name> ")"

  <boxed-decl>  ::=  "(" "define-boxed" <name> <func> <func> [<size>] ")"
  <func>        ::=  <name>
  <size>        ::=  <string>

  <signal-decl> ::=  "(" "define-signal" <name> <signame> [<sigtype>] ")"
  <signame>     ::=  <string>
  <sigtype>     ::=  "(" <type> <pars> ")"


  <pardefaults> ::=  "(" <pardefault>* ")"
  <pardefault>  ::=  "(" <type> <name> [<flag>] [<default>] ")"
  <pars>        ::=  "(" <par>* ")"
  <par>         ::=  "(" <type> <name> ")"

  <type>    ::=  <word>
  <flag>    ::=  "(" "null-ok" ")"  |  "(" "output" ")"
  <default> ::=  "(" "=" <string> ")"

  <name>     a sequence of letters, -, and _ beginning with a letter
  <word>     ditto
  <string>   anything encapsulated in double quotes


here

+  <nt>*  denotes zero or more occurrences of  <nt>  ; 
+  <nt>+  denotes one or more occurrences of  <nt>  ; 
+  [<nt>]  denotes zero or one occurrence of  <nt>  .
]]>
</programlisting>
</para>

<para>
The specification of signals is not standard; all other grammar rules
are induced from the <filename>gtk.defs</filename> file in the
<system>PyGtk</system> distribution. However, <system>PyGtk</system>
does not specify signals, and consequently a declaration in the style
of the remaining declarations was added.
</para>

<para>
TODO: 
* could we improve things by not differentiating between pardefaults
  and pars?
</para>

</sect1>

<sect1><title>Translation</title>

<para>
This section lists example translations of parts of the current
gtk.defs file.
</para>

<sect2><title>Objects</title>

<para>
The .defs file contains

  <programlisting role="Scheme">
    (define-object GtkDialog (GtkWindow)
       (fields
          (GtkVBox vbox)
          (GtkHBox action_area)))
  </programlisting>
</para>

<para>
To facilitate access to the subwidgets of a widget (which in C is
handled by simply casting the widget pointer to the correct type and
then accessing the fields), we need to provide SML functions that
extract these subwidgets of a widget, since the SML program cannot
simply access the fields.
</para>

<para>
The corresponding generated code is

<itemizedlist>

<listitem><para><filename>.c</filename>
  <programlisting role="C">
    /* *** Dialog stuff *** */

    /* ML type: gtkobj -> gtkobj */
    value mgtk_dialog_get_vbox(value wid) { /* ML */
      return Val_GtkObj((GTK_DIALOG(GtkObj_val(wid))) -> vbox);
    }
  </programlisting>
</para></listitem>

<listitem><para><filename>.sig</filename>
  <programlisting role="SML">
    (* *** Dialog *** *)

    type 'a dialog_t
    type 'a GtkDialog = 'a dialog_t GtkWindow

    val dialog_get_vbox: 'a GtkDialog -> base GtkVBox
    ...
  </programlisting>
</para></listitem>

<listitem><para><filename>.sml</filename>
  <programlisting role="SML">
    (* *** Dialog *** *)

    type 'a dialog_t = base
    type 'a GtkDialog = 'a dialog_t GtkWindow

    val dialog_get_vbox_: gtkobj -> gtkobj
        = app1(symb"mgtk_dialog_get_vbox")
    val dialog_get_vbox: 'a GtkDialog -> base GtkVBox
        = fn OBJ wid => OBJ(dialog_get_vbox_ wid)

    ...
  </programlisting>
</para></listitem>

</itemizedlist>
</para>

</sect2>


<sect2><title>Functions</title>

<para>
The <filename>.defs</filename> file contains
  <programlisting role="Scheme">
    (define-func gtk_frame_new
       GtkFrame
       ((string label (null-ok))))
  </programlisting>
and
  <programlisting role="Scheme">
    (define-func gtk_label_get
       none
       ((GtkLabel label)
        (string str (output))))
  </programlisting>
</para>

<para>
The corresponding generated code is

<itemizedlist>

<listitem><para><filename>.c</filename>
  <programlisting role="C">
    /* ML type: string option -> gtkobj */
    value mgtk_frame_new(value label) { /* ML */
      return Val_GtkObj(gtk_frame_new(StringOption_nullok(label)));
    }

    /* ML type: unit -> gtkobj */
    value mgtk_frame_new_short() { /* ML */
      return Val_GtkObj(gtk_frame_new(NULL));
    }
  </programlisting>
and
  <programlisting role="C">
    /* ML type: gtkobj -> string */
    value mgtk_label_get(value label) { /* ML */
      char* resstr;
      gtk_label_get(GtkObj_val(label), &resstr);
      return copy_string(resstr);
    }
  </programlisting>
</para></listitem>

<listitem><para><filename>.sig</filename>
  <programlisting role="SML">
    val frame_new: string option -> base GtkFrame
    val frame_new': unit -> base GtkFrame
  </programlisting>
and
  <programlisting role="SML">
    val label_get: 'a GtkLabel -> string
  </programlisting>
</para></listitem>

<listitem><para><filename>.sml</filename>
  <programlisting role="SML">
    val frame_new_: string option -> gtkobj
        = app1(symb"mgtk_frame_new")
    val frame_new: string option -> base GtkFrame
        = fn label => OBJ(frame_new_ label)

    val frame_new'_: unit -> gtkobj
        = app1(symb"mgtk_frame_new_short")
    val frame_new': unit -> base GtkFrame
        = fn label => OBJ(frame_new'_ label)
  </programlisting>
and
  <programlisting role="SML">
    val label_get_: gtkobj -> string
        = app1(symb"mgtk_label_get")
    val label_get: 'a GtkLabel -> string
        = fn OBJ label => label_get_ label
  </programlisting>
</para></listitem>

</itemizedlist>
</para>

</sect2>

<sect2><title>Enumerations</title>

<para>
The <filename>.defs</filename> file contains
  <programlisting role="Scheme">
    (define-enum GtkArrowType
       (up GTK_ARROW_UP)
       (down GTK_ARROW_DOWN)
       (left GTK_ARROW_LEFT)
       (right GTK_ARROW_RIGHT))
  </programlisting>
</para>

<para>
We need access to the correct integer values of the enumeration
constants. This is provided by
<function>mgtk_get_arrow_type</function> (a C function) that
constructs a tuple of all constants, which is bound to SML values in
<filename>Gtk.sml</filename>.
</para>

<para>
The corresponding generated code is

<itemizedlist>

<listitem><para><filename>.c</filename>
  <programlisting role="C">
    /* ML type: unit -> int * int * int * int */
    value mgtk_get_arrow_type (value dummy) { /* ML */
      value res = alloc_tuple(4);
      Field(res,0) = Val_int(GTK_ARROW_UP);
      Field(res,1) = Val_int(GTK_ARROW_DOWN);
      Field(res,2) = Val_int(GTK_ARROW_LEFT);
      Field(res,3) = Val_int(GTK_ARROW_RIGHT);
      return res;
    }
  </programlisting>
</para></listitem>

<listitem><para><filename>.sig</filename>
  <programlisting role="SML">
    type arrow_type
    val ARROW_UP: arrow_type
    val ARROW_DOWN: arrow_type
    val ARROW_LEFT: arrow_type
    val ARROW_RIGHT: arrow_type
  </programlisting>
</para></listitem>

<listitem><para><filename>.sml</filename>
  <programlisting role="SML">
    type arrow_type = int
    val get_arrow_type_: unit -> int * int * int * int
        = app1(symb"mgtk_get_arrow_type")
    val (ARROW_UP,ARROW_DOWN,ARROW_LEFT,ARROW_RIGHT)
        = get_arrow_type_ ()
  </programlisting>
</para></listitem>

</itemizedlist>
</para>

</sect2>

<sect2><title>Boxed types</title>

<para>
The <filename>.defs</filename> file contains
  <programlisting role="Scheme" format=linespecific>
    (define-boxed GdkFont
       gdk_font_ref
       gdk_font_unref)
  </programlisting>
</para>

<para>
The corresponding generated code is

<itemizedlist>

<listitem><para><filename>.c</filename> We need code to convert from
  the type of ML values to C values (<function>GdkFont_val</function>,
  below) and the other way (<function>Val_GdkFont</function>,
  below). Being a boxed type, we have to remember to increase/decrease
  reference counts with the supplied functions.
  <programlisting role="C">
    #define GdkFont_val(x) ((void*) Field(x, 1))

    static void ml_finalize_gdk_font (value val) {
      gdk_font_unref (GdkFont_val(val)); 
    }

    value Val_GdkFont (void* obj) {
      value res;
      gdk_font_ref(obj);
      res = alloc_final (2, ml_finalize_gdk_font, 0, 1);
      GdkFont_val(res) = (value) obj ;
      return res;
    }
  </programlisting>
</para></listitem>

<listitem><para><filename>.sig</filename>
  <programlisting role="SML">
    type gdk_font
  </programlisting>
</para></listitem>

<listitem><para><filename>.sml</filename>
  <programlisting role="SML">
    prim_type gdk_font
  </programlisting>
</para></listitem>

</itemizedlist>
</para>

</sect2>

<sect2><title>Signals</title>

<para>
(Remember that this is non-standard, refer to Section 2.)
</para>

<para>
The <filename>.defs</filename> file contains
<programlisting role="Scheme">
    (define-signal GtkButton "clicked")
</programlisting>
</para>

<para>
The corresponding generated code is

<itemizedlist>

<listitem><para><filename>.c</filename> (nothing---everything is
  supported by the header files; refer to
  <filename>header.c</filename> and <filename>header.sml</filename>
  for details).
</para></listitem>

<listitem><para><filename>.sig</filename>
  <programlisting role="SML">
    val connect_clicked: 'a GtkButton -> (unit -> unit) -> unit
  </programlisting>
</para></listitem>

<listitem><para><filename>.sml</filename>
  <programlisting role="SML">

    val connect_clicked: 'a GtkButton -> (unit -> unit) -> unit
        = fn wid => fn cb => unit_connect wid "clicked" cb
  </programlisting>
</para></listitem>

</itemizedlist>
</para>

</sect2>

</sect1>

</article>