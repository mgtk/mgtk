\documentclass[workingdraft,endnotes]{usetex-v1}
% 1. workingdraft:
%
%       For initial submission and shepherding.  Features prominent
%       date, notice of draft status, page numbers, and annotation
%       facilities.  The three supported annotation macros are:
%               \edannote{text}         -- anonymous annotation note
%               \begin{ednote}{who}     -- annotation note attributed
%                 text                          to ``who''
%               \end{ednote}
%               \HERE                   -- a marker that can be left
%                                               in the text and easily
%                                               searched for later
%
% In addition, the option "endnotes" permits the use of the
% otherwise-disabled, Usenix-deprecated footnote{} command in
% documents.  In this case, be sure to include a
% \makeendnotes command at the end of your document or
% the endnotes will not actually appear.
%
\usepackage{preamble}




\begin{document}

\title{mGTK}

\docstatus{Submitted to USENIX'04 (FREENIX track)}

\author{
\authname{Ken Friis Larsen}
%\authaddr{Your Department}
%\authaddr{Your Institution}
%\authaddr{ Your City, State, ZIP}
\authurl{\url{ken@friislarsen.net}}
%\authurl{\url{http://host.dom/yoururl}}
\and
\authname{Henning Niss}
\authaddr{Department of Innovation}
\authaddr{IT University of Copenhagen}
\authaddr{Denmark}
\authurl{\url{hniss@it.edu}}
\authurl{\url{http://www.it.edu/people/hniss}}
%
} % end author

\maketitle

\begin{abstract}
  We describe \mgtk a language binding that makes the graphical
  toolkit \gtk, written in C, accessible for programs written in the
  programming language Standard~ML (\sml).  This is not a trivial task
  because \gtk is based on an object-oriented and \sml is functional
  language with a non--object-oriented type system.  In this paper we
  describe how it is possible to encode a single-inheritance
  class-hierarchy using \sml's type system and we describe how we
  machine-generate most of the library to utilise the limited
  man-power of the project.
\end{abstract}



\section{Introduction}
\label{sec:intr-backgr}



\subsection{Standard ML and GTK+}

\begin{ednote}{Ken}
  * Hvad og hvorfor: SML  
  
  * Gtk+ er interessant (og C var et godt
    impl. valg)  
  
  * SML er ikke OO (tester Gtk+-folkenes "hypotese")
\end{ednote}

Standard ML (\sml) is a functional language with imperative features
widely used for teaching and in reasearch. 



\subsection{Overview of this paper}
\label{sec:overview-this-paper}



\section{Encoding of classes}
\label{sec:encoding-classes}


\begin{ednote}{Ken}
  * Phantom types are inheritance paths.

  * We have one witness type per subtype.
  
  * We get upcasts for free.
  
  * Use base for plumbing.

  * Only single-inheritance is handled.
\end{ednote}



\section{Example}
\label{sec:example}

\begin{ednote}{}
  Perhaps we can move this example further up the paper,
  and thereby introduce SML lingo.
\end{ednote}

\begin{ednote}{}
  Mini-mgtk and a hello-world example
\end{ednote}

\begin{figure*}[htbp]
\begin{centering}
\begin{verbatim}
fun hello _ = print "Hello World\n"

fun main _ =
    let val _ = 
           GtkBasis.init(CommandLine.name()::CommandLine.arguments())
        val window = Window.new ()
        val button = Button.new_with_label "Hello World"
    in  Signal.connect window (Widget.delete_event_sig (fn _ => false))
      ; Signal.connect window (Widget.destroy_sig GtkBasis.main_quit)
      ; Signal.connect button (Button.clicked_sig hello)
      ; Container.add window button
      ; Widget.show_all window
      ; GtkBasis.main() 
    end

val _ = main()
\end{verbatim}
\caption{Hello World in mGTK.\label{fig:hello-world}}
\end{centering}
\end{figure*}
In Figure~\ref{fig:hello-world} we use the following SML constructs
(see a textbook on SML for further examples;
\cite{Hansen-Rischel:1999,Paulson:1996} for example). The construct
\texttt{fun} \textit{foo} \textit{x} \texttt{=} \textit{exp} declares
a function \textit{foo} that has one formal parameter \textit{x} and
function body \textit{exp}; \texttt{fn} \textit{x} \texttt{=>}
\textit{exp} denotes a similar \emph{anonymous} function. If one does
not care about the parameter, one can use the \emph{wildcard}
\texttt{\_}. The construct \texttt{let}~\texttt{val} \textit{x} \texttt{=}
\textit{exp} declares the identifier \textit{x} to be bound to the
value obtained by evaluating \textit{exp}. If the only reason
for evaluating \textit{exp} is any potential side effect, one
can again use the wildcard \texttt{\_}. Expressions evaluated for
their side effects can also be sequentialized using \texttt{;}.
The value \texttt{()}, ``unit'', can be used as is and is also used
as the return value of purely side-effecting functions.
Finally, \textit{Foo}\texttt{.}\textit{bar} denotes the value bound
to the identifier \textit{bar} in module \textit{Foo}, and
\texttt{::} denotes the cons operation on lists as in
\textit{hd}\texttt{::}\textit{tl}.

Example base types are {\tUnit} for the unit value \texttt{()},
{\tInt} for integer values, and {\tBool} for boolean values. The type
of a list of integers is \tList{\tInt}. The type of a function
expecting an integer list argument and returning an integer result is
\tArrow{(\tList\tInt)}{\tInt}; the \textit{length} function on lists
would have such a type, for example. 

Some functions never need to
``inspect'' (sub)parts of supplied arguments values; such functions
are called \emph{polymorphic}. For example, the function that just
returns it's argument unchanged (the ``identity function'') is
polymorphic; so is the function that computes the length of a list. We
indicate the parts of the values that are not inspected by using type
variables $\alpha, \beta, \ldots$ at the corresponding locations in
the type. For example, the type of the identity function is
$\tArrow{\alpha}{\alpha}$ telling us that we can apply to any type of
argument, and we get back a value of the same type. The
\textit{length} function has type $\tArrow{\tList\alpha}{\tInt}$
because, regardless of the type of elements in the list (here denoted
$\alpha$), the function can compute the length of the list. Such type
variables are \emph{instantiated} to (more) specific types when we
apply the polymorphic function. For example, when we apply the
polymorphic identity function to \texttt{()} we instantiate $\alpha$
to {\tUnit} giving this occurence of the function the type
\tArrow\tUnit\tUnit; when we apply it to \texttt{17} we instantiate
$\alpha$ to {\tInt} and the occurrence of the function gets type
\tArrow\tInt\tInt. The function is said to be (parametric) polymorphic
because we can apply it to arguments of many shapes.

\section{Process}
\label{sec:process}

\begin{ednote}{Henning}
  Fra mini muck-up til fuld toolkit
\end{ednote}


\subsection{Stubs and code generation}
\label{sec:stubs-code-gener}





\section{Synergy}
\label{sec:synergy}

\begin{ednote}{Henning}
  SML + Gtk+ er godt
\end{ednote}



\section{Supported \sml compilers}
\label{sec:supp-sml-comp}

\begin{ednote}{Henning}
  MLton og Moscow ML (SML.NET med Gtk\#?)
\end{ednote}


\section{Related work}
\label{sec:related-work}

 Brainstorm of related work:
\begin{itemize}
\item SML-GTK 
\url{http://www.cs.nyu.edu/phd_students/leunga/sml-gtk/sml-gtk.html}

\item gtk+hs
\url{http://www.cse.unsw.edu.au/~chak/haskell/gtk}

\item lablgtk
\url{http://wwwfun.kurims.kyoto-u.ac.jp/soft/olabl/lablgtk.html}

\item sml\_tk
\url{http://www.informatik.uni-bremen.de/~cxl/sml_tk}

\item erlgtk
\url{http://erlgtk.sourceforge.net}

\end{itemize}



\section{Future Work}
\label{sec:future-work}

\begin{itemize}
\item Wrap all the libraries in the GNOME development platform
\end{itemize}



\section{Conclusion}
\label{sec:conclusion}

In this paper we have demonstrated that is theoretical and practically
possible to make an interface from SML to GTK.

\bibliographystyle{abbrv}
\bibliography{mgtk}

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
